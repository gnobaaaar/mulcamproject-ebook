A path based set where the most specific path wins.

### Synopsis

```javascript
var assert = require('assert')
var supersede = require('supersede')

// create a set
var set = new Supersede

// set a value keyed to a path of depth 2.
set.set('.hello.world'.split('.'), 'hello, world')

// get the value
assert.equal(set.get('.hello.world'), 'hello, world')

// get a non-existant value
assert.equal(set.get('.hello.earth'), null)

// set a value keyed to a path of depth 1.
assert.equal(set.get('.hello'), 'hello, you')

// parent value is used
assert.equal(set.get('.hello.earth'), 'hello, earth')

// the most specific path wins
assert.equal(set.get('.hello.world'), 'hello, world')

// gather along a path
assert.deepEqual(set.gather('.hello.world'), [ 'hello, earth', 'hello, world' ])
```

### Usage

Keys are generated by calling `split('.')` on a path string that begins with a
dot `'.'` where path steps are dot `'.'` delimited.

```javascript
var assert = require('assert')

var rootPath = '.'.split('.')
var otherPath = '.hello.world'.split('.')

assert.deepEqual(rootPath, [ '', '' ])
assert.deepEqual(otherPath, [ '', 'hello', 'world' ])
```

Supersede does not perform this split itself because if you're really in a
hurry you might want to save the generated arrays for later use, or type out the
key as an array literal.

#### `supersede = new Supersede`

Create an empty set.

#### `supersede.set(path, value)`

Sets a key to the given value overriding any key.

#### `supersede.gather(path, value)`

Gathers the values along the given path into an array. If there are no values
along the path an empty array is returned.

#### `supersede.remove(path)`

Removes the value of the node specified by the given path.

### Diary

The star `'*'` here is special and needs to be used carefully. Using it to
remove all might not be the best.

What if we want to register a listener, so we place a `'*'` in the tree itself?
Then we can search a path where we look for everything that is the given step or
a star, but now we are getting into some recursive pattern matching. Do we
really want to match `'*'` star?


```javascript
signal.on('system.web.rost', handler1)
signal.on('system.*.error', handler2)

signal.on('system.web.logger.info', logger.info)
```

What is going to be useful? So much thought to put into late binding.

The only place that is useful is in `gather`, so I can make a new function that
respsects that, but it would be slightly more expensive than `gather`, but only
slightly more. It will not be universal. It can only be for `'*'`.
